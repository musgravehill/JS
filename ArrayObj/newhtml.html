<!DOCTYPE html>
<html>
    <head>
        <title>TODO supply a title</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
    </head>
    <body>
        const arr = ['a', 'b', 'c', , , ];
        arr.test = 'bad'; //нечисловые ключи или унаследованные ключи
        
        
         //Не пропускает пустой элемент. 
         //сохраняют значение this из внешней области
        for(let idx=0; idx< arr.length; idx++) 
        
        
        //пропускают пустой элемент
        // НЕ сохраняют значение this из внешней области видимости. Чтобы сохранить, пиши ()=>{}
        //async/await проблема
        //генератор  yield проблема
        arr.forEach((val,idx)=>{}) 

        
        
        //Выводит нечисловые ключи или унаследованные ключи
        //пропускают пустой элемент
        //сохраняют значение this из внешней области видимости
        for(let idx in arr)          


        //Не пропускает пустой элемент. 
        //сохраняют значение this из внешней области. самый надежный способ
        for(const val of arr) 
        for (const [i, v] of arr.entries()) {
        console.log(i, v); // Prints "0 a", "1 b", "2 c"
        }

        ------
        var arr = [1, -1, 2, -2, 3];
        var positiveArr = arr.filter(function(val,idx,arr) {
        return val > 0;
        });
        alert( positiveArr ); // 1,2,3

        -----
        var names = ['HTML', 'CSS', 'JavaScript'];
        var nameLengths = names.map(function(name,idx,arr) {
        return name.length;
        });
        // получили массив с длинами
        alert( nameLengths ); // 4,3,10

        ----
        var arr = [1, -1, 2, -2, 3];
        function isPositive(number) {
        return number > 0;
        }
        alert( arr.every(isPositive) ); // false, не все положительные
        alert( arr.some(isPositive) ); // true, есть хоть одно положительное

        ----
        reduce/reduceRight
        reduce/reduceRight
        Метод «arr.reduce(callback[, initialValue])» используется для последовательной обработки каждого элемента массива с сохранением промежуточного результата.


        Он применяет функцию callback по очереди к каждому элементу массива слева направо, сохраняя при этом промежуточный результат.

        Аргументы функции callback(previousValue, currentItem, index, arr):

        previousValue – последний результат вызова функции, он же «промежуточный результат».
        currentItem – текущий элемент массива, элементы перебираются по очереди слева-направо.
        index – номер текущего элемента.
        arr – обрабатываемый массив.
        Кроме callback, методу можно передать «начальное значение» – аргумент initialValue. Если он есть, то на первом вызове значение previousValue будет равно initialValue, а если у reduce нет второго аргумента, то оно равно первому элементу массива, а перебор начинается со второго.

        Проще всего понять работу метода reduce на примере.
        Например, в качестве «свёртки» мы хотим получить сумму всех элементов массива.
        Вот решение в одну строку:
        var arr = [1, 2, 3, 4, 5]
        // для каждого элемента массива запустить функцию,
        // промежуточный результат передавать первым аргументом далее
        var result = arr.reduce(function(sum, current) {
        return sum + current;
        }, 0);
        alert( result ); // 15


    </body>
    <script>
        const inputArr = [
            {color: 'white', id: 1},
            {color: 'red', id: 2},
            {color: 'white', id: 3},
            {color: 'green', id: 4},
            {color: 'green', id: 5}
        ];
        function ioFunc1(inputArr) {
            let res = {};
            for (const el of inputArr) {
                if (!res.hasOwnProperty(el.color)) {
                    res[el.color] = {};
                }
                res[el.color][el.id] = {[el.id]: el};
            }
            return res;
        }

        function ioFunc(inputArr) {
            let res = {};

            res = inputArr.reduce(function (memo, el) {
                if (!memo.hasOwnProperty(el.color)) {
                    memo[el.color] = {};
                }
                memo[el.color][el.id] = {[el.id]: el};
                return memo;
            }, {});

            return res;
        }

        const res = ioFunc(inputArr);
        console.log(res);

        /* const out = {
         'white': {
         1: {color: 'white', id: 1},
         3: {color: 'white', id: 3}
         },
         'red': {
         2: {color: 'red', id: 2}
         },
         'green': {
         4: {color: 'green', id: 4},
         5: {color: 'green', id: 5}
         }
         };*/
    </script>
</html>
