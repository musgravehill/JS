<!DOCTYPE html>
<html>
    <head>
        <title>TODO supply a title</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
    </head>
    <body>
        <div>event loop </div>

        Параллелизм/Многопоточность в JavaScript работает за счёт цикла событий (event loop), 
        который отвечает за выполнение кода, сбора и обработки событий 
        и выполнения под-задач из очереди (queued sub-tasks). 

        Идея событийного цикла очень проста. Есть бесконечный цикл, в котором движок JavaScript ожидает задачи, исполняет их и снова ожидает появления новых.        

        Вызов функции создает контекст выполнения Execution Context. В стек вызовов Call Stack сохраняется вся история контекстов для вложенных функций. 
        Когда всё выполнилось, call stack чистится.

        Объекты размещаются в Куче Heap. - большой неструктурированной области памяти.

        1. выполнить самую старую макро-задачу из очереди task queue.
        2. исполнить все микро-задачи в текущем окружении. microtask queue
        3. отрисовать страницу
        4. ждать появления нового


        Есть 3 очереди:
        1. task queue   (onclick, setTimeout, postMessage)
        2. micro-task queue (promise resolve then catch, queueMicrotask)
        3. render queue (style layout paint composite)

        WebAPI (DOM, XHR fetch) 



        Чтобы добавить в очередь новую макрозадачу:

        Используйте setTimeout(f) с нулевой задержкой.
        Этот способ можно использовать для разбиения больших вычислительных задач на части, чтобы браузер мог реагировать на пользовательские события и показывать прогресс выполнения этих частей.

        Также это используется в обработчиках событий для отложенного выполнения действия после того, как событие полностью обработано (всплытие завершено).

        Для добавления в очередь новой микрозадачи:

        Используйте queueMicrotask(f).
        Также обработчики промисов выполняются в рамках очереди микрозадач.
        События пользовательского интерфейса и сетевые события в промежутках между микрозадачами не обрабатываются: микрозадачи исполняются непрерывно одна за другой.

        Поэтому queueMicrotask можно использовать для асинхронного выполнения функции в том же состоянии окружения.

        ------------
        Обработчики промисов .then/.catch/.finally всегда асинхронны.
        Даже когда промис сразу же выполнен, код в строках ниже ".then/.catch/.finally" будет запущен до этих обработчиков.

        micro-task queue определяется как первым-пришёл-первым-ушёл (FIFO): задачи, попавшие в micro-task queue первыми, выполняются тоже первыми.
        Выполнение задачи происходит только в том случае, если ничего больше не запущено.
        Или, проще говоря, когда промис выполнен, его обработчики .then/catch/finally попадают в очередь. Они пока не выполняются. 
        Движок JavaScript берёт задачу из очереди и выполняет её, когда он освободится от выполнения текущего кода.
        Обработчики промисов всегда проходят через эту внутреннюю очередь micro-task queue.

        Если есть цепочка с несколькими .then/catch/finally, то каждый из них выполняется асинхронно. 
        То есть сначала ставится в очередь, а потом выполняется, когда выполнение текущего кода завершено и добавленные ранее в очередь обработчики выполнены.

        Таким образом, обработчики .then/catch/finally вызываются после выполнения текущего кода. 
        Если нам нужно гарантировать выполнение какого-то кода после .then/catch/finally, то лучше всего добавить его вызов в цепочку .then.

        -----        
        Связь нескольких потоков между собой
        Web Worker или кросс-доменный фрейм имеют свой собственный стек, кучу и очередь событий. 
        Два отдельных событийных потока могут связываться друг с другом, только через отправку сообщений с помощью метода postMessage. 
        Этот метод добавляет сообщение  в очередь другого, если он конечно принимает их.

        Никогда не блокируется
        Очень интересное свойство цикла событий в JavaScript, что в отличие от множества других языков, поток выполнения никогда не блокируется. 
        Обработка I/O обычно осуществляется с помощью событий и колбэк-функций, поэтому даже когда приложение ожидает запрос от IndexedDB или ответ от XHR, 
        оно может обрабатывать другие процессы, например пользовательский ввод.




    </body>
</html>
